module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateGuest {
  count: Int!
}

type AggregateGuestContact {
  count: Int!
}

type AggregateGuestPersonal {
  count: Int!
}

type AggregateGuestResponse {
  count: Int!
}

type AggregateGuestRsvp {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Guest {
  id: ID!
  contact: GuestContact!
  personal: GuestPersonal!
  rsvp: GuestRsvp!
}

type GuestConnection {
  pageInfo: PageInfo!
  edges: [GuestEdge]!
  aggregate: AggregateGuest!
}

type GuestContact {
  id: Int!
  address: String
  email: String!
}

type GuestContactConnection {
  pageInfo: PageInfo!
  edges: [GuestContactEdge]!
  aggregate: AggregateGuestContact!
}

input GuestContactCreateInput {
  id: Int
  address: String
  email: String!
}

input GuestContactCreateOneInput {
  create: GuestContactCreateInput
  connect: GuestContactWhereUniqueInput
}

type GuestContactEdge {
  node: GuestContact!
  cursor: String!
}

enum GuestContactOrderByInput {
  id_ASC
  id_DESC
  address_ASC
  address_DESC
  email_ASC
  email_DESC
}

type GuestContactPreviousValues {
  id: Int!
  address: String
  email: String!
}

type GuestContactSubscriptionPayload {
  mutation: MutationType!
  node: GuestContact
  updatedFields: [String!]
  previousValues: GuestContactPreviousValues
}

input GuestContactSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuestContactWhereInput
  AND: [GuestContactSubscriptionWhereInput!]
  OR: [GuestContactSubscriptionWhereInput!]
  NOT: [GuestContactSubscriptionWhereInput!]
}

input GuestContactUpdateDataInput {
  address: String
  email: String
}

input GuestContactUpdateInput {
  address: String
  email: String
}

input GuestContactUpdateManyMutationInput {
  address: String
  email: String
}

input GuestContactUpdateOneRequiredInput {
  create: GuestContactCreateInput
  update: GuestContactUpdateDataInput
  upsert: GuestContactUpsertNestedInput
  connect: GuestContactWhereUniqueInput
}

input GuestContactUpsertNestedInput {
  update: GuestContactUpdateDataInput!
  create: GuestContactCreateInput!
}

input GuestContactWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  AND: [GuestContactWhereInput!]
  OR: [GuestContactWhereInput!]
  NOT: [GuestContactWhereInput!]
}

input GuestContactWhereUniqueInput {
  id: Int
}

input GuestCreateInput {
  id: ID
  contact: GuestContactCreateOneInput!
  personal: GuestPersonalCreateOneInput!
  rsvp: GuestRsvpCreateOneInput!
}

type GuestEdge {
  node: Guest!
  cursor: String!
}

enum GuestOrderByInput {
  id_ASC
  id_DESC
}

type GuestPersonal {
  id: Int!
  greeting: String
  nicknames: String!
}

type GuestPersonalConnection {
  pageInfo: PageInfo!
  edges: [GuestPersonalEdge]!
  aggregate: AggregateGuestPersonal!
}

input GuestPersonalCreateInput {
  id: Int
  greeting: String
  nicknames: String!
}

input GuestPersonalCreateOneInput {
  create: GuestPersonalCreateInput
  connect: GuestPersonalWhereUniqueInput
}

type GuestPersonalEdge {
  node: GuestPersonal!
  cursor: String!
}

enum GuestPersonalOrderByInput {
  id_ASC
  id_DESC
  greeting_ASC
  greeting_DESC
  nicknames_ASC
  nicknames_DESC
}

type GuestPersonalPreviousValues {
  id: Int!
  greeting: String
  nicknames: String!
}

type GuestPersonalSubscriptionPayload {
  mutation: MutationType!
  node: GuestPersonal
  updatedFields: [String!]
  previousValues: GuestPersonalPreviousValues
}

input GuestPersonalSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuestPersonalWhereInput
  AND: [GuestPersonalSubscriptionWhereInput!]
  OR: [GuestPersonalSubscriptionWhereInput!]
  NOT: [GuestPersonalSubscriptionWhereInput!]
}

input GuestPersonalUpdateDataInput {
  greeting: String
  nicknames: String
}

input GuestPersonalUpdateInput {
  greeting: String
  nicknames: String
}

input GuestPersonalUpdateManyMutationInput {
  greeting: String
  nicknames: String
}

input GuestPersonalUpdateOneRequiredInput {
  create: GuestPersonalCreateInput
  update: GuestPersonalUpdateDataInput
  upsert: GuestPersonalUpsertNestedInput
  connect: GuestPersonalWhereUniqueInput
}

input GuestPersonalUpsertNestedInput {
  update: GuestPersonalUpdateDataInput!
  create: GuestPersonalCreateInput!
}

input GuestPersonalWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  greeting: String
  greeting_not: String
  greeting_in: [String!]
  greeting_not_in: [String!]
  greeting_lt: String
  greeting_lte: String
  greeting_gt: String
  greeting_gte: String
  greeting_contains: String
  greeting_not_contains: String
  greeting_starts_with: String
  greeting_not_starts_with: String
  greeting_ends_with: String
  greeting_not_ends_with: String
  nicknames: String
  nicknames_not: String
  nicknames_in: [String!]
  nicknames_not_in: [String!]
  nicknames_lt: String
  nicknames_lte: String
  nicknames_gt: String
  nicknames_gte: String
  nicknames_contains: String
  nicknames_not_contains: String
  nicknames_starts_with: String
  nicknames_not_starts_with: String
  nicknames_ends_with: String
  nicknames_not_ends_with: String
  AND: [GuestPersonalWhereInput!]
  OR: [GuestPersonalWhereInput!]
  NOT: [GuestPersonalWhereInput!]
}

input GuestPersonalWhereUniqueInput {
  id: Int
}

type GuestPreviousValues {
  id: ID!
}

type GuestResponse {
  id: Int!
  attending: Boolean
  comments: String
  dietary: String
  name: String!
}

type GuestResponseConnection {
  pageInfo: PageInfo!
  edges: [GuestResponseEdge]!
  aggregate: AggregateGuestResponse!
}

input GuestResponseCreateInput {
  id: Int
  attending: Boolean
  comments: String
  dietary: String
  name: String!
}

input GuestResponseCreateManyInput {
  create: [GuestResponseCreateInput!]
  connect: [GuestResponseWhereUniqueInput!]
}

type GuestResponseEdge {
  node: GuestResponse!
  cursor: String!
}

enum GuestResponseOrderByInput {
  id_ASC
  id_DESC
  attending_ASC
  attending_DESC
  comments_ASC
  comments_DESC
  dietary_ASC
  dietary_DESC
  name_ASC
  name_DESC
}

type GuestResponsePreviousValues {
  id: Int!
  attending: Boolean
  comments: String
  dietary: String
  name: String!
}

input GuestResponseScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  attending: Boolean
  attending_not: Boolean
  comments: String
  comments_not: String
  comments_in: [String!]
  comments_not_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_gt: String
  comments_gte: String
  comments_contains: String
  comments_not_contains: String
  comments_starts_with: String
  comments_not_starts_with: String
  comments_ends_with: String
  comments_not_ends_with: String
  dietary: String
  dietary_not: String
  dietary_in: [String!]
  dietary_not_in: [String!]
  dietary_lt: String
  dietary_lte: String
  dietary_gt: String
  dietary_gte: String
  dietary_contains: String
  dietary_not_contains: String
  dietary_starts_with: String
  dietary_not_starts_with: String
  dietary_ends_with: String
  dietary_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GuestResponseScalarWhereInput!]
  OR: [GuestResponseScalarWhereInput!]
  NOT: [GuestResponseScalarWhereInput!]
}

type GuestResponseSubscriptionPayload {
  mutation: MutationType!
  node: GuestResponse
  updatedFields: [String!]
  previousValues: GuestResponsePreviousValues
}

input GuestResponseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuestResponseWhereInput
  AND: [GuestResponseSubscriptionWhereInput!]
  OR: [GuestResponseSubscriptionWhereInput!]
  NOT: [GuestResponseSubscriptionWhereInput!]
}

input GuestResponseUpdateDataInput {
  attending: Boolean
  comments: String
  dietary: String
  name: String
}

input GuestResponseUpdateInput {
  attending: Boolean
  comments: String
  dietary: String
  name: String
}

input GuestResponseUpdateManyDataInput {
  attending: Boolean
  comments: String
  dietary: String
  name: String
}

input GuestResponseUpdateManyInput {
  create: [GuestResponseCreateInput!]
  update: [GuestResponseUpdateWithWhereUniqueNestedInput!]
  upsert: [GuestResponseUpsertWithWhereUniqueNestedInput!]
  delete: [GuestResponseWhereUniqueInput!]
  connect: [GuestResponseWhereUniqueInput!]
  set: [GuestResponseWhereUniqueInput!]
  disconnect: [GuestResponseWhereUniqueInput!]
  deleteMany: [GuestResponseScalarWhereInput!]
  updateMany: [GuestResponseUpdateManyWithWhereNestedInput!]
}

input GuestResponseUpdateManyMutationInput {
  attending: Boolean
  comments: String
  dietary: String
  name: String
}

input GuestResponseUpdateManyWithWhereNestedInput {
  where: GuestResponseScalarWhereInput!
  data: GuestResponseUpdateManyDataInput!
}

input GuestResponseUpdateWithWhereUniqueNestedInput {
  where: GuestResponseWhereUniqueInput!
  data: GuestResponseUpdateDataInput!
}

input GuestResponseUpsertWithWhereUniqueNestedInput {
  where: GuestResponseWhereUniqueInput!
  update: GuestResponseUpdateDataInput!
  create: GuestResponseCreateInput!
}

input GuestResponseWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  attending: Boolean
  attending_not: Boolean
  comments: String
  comments_not: String
  comments_in: [String!]
  comments_not_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_gt: String
  comments_gte: String
  comments_contains: String
  comments_not_contains: String
  comments_starts_with: String
  comments_not_starts_with: String
  comments_ends_with: String
  comments_not_ends_with: String
  dietary: String
  dietary_not: String
  dietary_in: [String!]
  dietary_not_in: [String!]
  dietary_lt: String
  dietary_lte: String
  dietary_gt: String
  dietary_gte: String
  dietary_contains: String
  dietary_not_contains: String
  dietary_starts_with: String
  dietary_not_starts_with: String
  dietary_ends_with: String
  dietary_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GuestResponseWhereInput!]
  OR: [GuestResponseWhereInput!]
  NOT: [GuestResponseWhereInput!]
}

input GuestResponseWhereUniqueInput {
  id: Int
}

type GuestRsvp {
  id: Int!
  date: String
  responded: Boolean!
  responses(where: GuestResponseWhereInput, orderBy: GuestResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GuestResponse!]
}

type GuestRsvpConnection {
  pageInfo: PageInfo!
  edges: [GuestRsvpEdge]!
  aggregate: AggregateGuestRsvp!
}

input GuestRsvpCreateInput {
  id: Int
  date: String
  responded: Boolean!
  responses: GuestResponseCreateManyInput
}

input GuestRsvpCreateOneInput {
  create: GuestRsvpCreateInput
  connect: GuestRsvpWhereUniqueInput
}

type GuestRsvpEdge {
  node: GuestRsvp!
  cursor: String!
}

enum GuestRsvpOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  responded_ASC
  responded_DESC
}

type GuestRsvpPreviousValues {
  id: Int!
  date: String
  responded: Boolean!
}

type GuestRsvpSubscriptionPayload {
  mutation: MutationType!
  node: GuestRsvp
  updatedFields: [String!]
  previousValues: GuestRsvpPreviousValues
}

input GuestRsvpSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuestRsvpWhereInput
  AND: [GuestRsvpSubscriptionWhereInput!]
  OR: [GuestRsvpSubscriptionWhereInput!]
  NOT: [GuestRsvpSubscriptionWhereInput!]
}

input GuestRsvpUpdateDataInput {
  date: String
  responded: Boolean
  responses: GuestResponseUpdateManyInput
}

input GuestRsvpUpdateInput {
  date: String
  responded: Boolean
  responses: GuestResponseUpdateManyInput
}

input GuestRsvpUpdateManyMutationInput {
  date: String
  responded: Boolean
}

input GuestRsvpUpdateOneRequiredInput {
  create: GuestRsvpCreateInput
  update: GuestRsvpUpdateDataInput
  upsert: GuestRsvpUpsertNestedInput
  connect: GuestRsvpWhereUniqueInput
}

input GuestRsvpUpsertNestedInput {
  update: GuestRsvpUpdateDataInput!
  create: GuestRsvpCreateInput!
}

input GuestRsvpWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  responded: Boolean
  responded_not: Boolean
  responses_every: GuestResponseWhereInput
  responses_some: GuestResponseWhereInput
  responses_none: GuestResponseWhereInput
  AND: [GuestRsvpWhereInput!]
  OR: [GuestRsvpWhereInput!]
  NOT: [GuestRsvpWhereInput!]
}

input GuestRsvpWhereUniqueInput {
  id: Int
}

type GuestSubscriptionPayload {
  mutation: MutationType!
  node: Guest
  updatedFields: [String!]
  previousValues: GuestPreviousValues
}

input GuestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuestWhereInput
  AND: [GuestSubscriptionWhereInput!]
  OR: [GuestSubscriptionWhereInput!]
  NOT: [GuestSubscriptionWhereInput!]
}

input GuestUpdateInput {
  contact: GuestContactUpdateOneRequiredInput
  personal: GuestPersonalUpdateOneRequiredInput
  rsvp: GuestRsvpUpdateOneRequiredInput
}

input GuestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  contact: GuestContactWhereInput
  personal: GuestPersonalWhereInput
  rsvp: GuestRsvpWhereInput
  AND: [GuestWhereInput!]
  OR: [GuestWhereInput!]
  NOT: [GuestWhereInput!]
}

input GuestWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createGuest(data: GuestCreateInput!): Guest!
  updateGuest(data: GuestUpdateInput!, where: GuestWhereUniqueInput!): Guest
  upsertGuest(where: GuestWhereUniqueInput!, create: GuestCreateInput!, update: GuestUpdateInput!): Guest!
  deleteGuest(where: GuestWhereUniqueInput!): Guest
  deleteManyGuests(where: GuestWhereInput): BatchPayload!
  createGuestContact(data: GuestContactCreateInput!): GuestContact!
  updateGuestContact(data: GuestContactUpdateInput!, where: GuestContactWhereUniqueInput!): GuestContact
  updateManyGuestContacts(data: GuestContactUpdateManyMutationInput!, where: GuestContactWhereInput): BatchPayload!
  upsertGuestContact(where: GuestContactWhereUniqueInput!, create: GuestContactCreateInput!, update: GuestContactUpdateInput!): GuestContact!
  deleteGuestContact(where: GuestContactWhereUniqueInput!): GuestContact
  deleteManyGuestContacts(where: GuestContactWhereInput): BatchPayload!
  createGuestPersonal(data: GuestPersonalCreateInput!): GuestPersonal!
  updateGuestPersonal(data: GuestPersonalUpdateInput!, where: GuestPersonalWhereUniqueInput!): GuestPersonal
  updateManyGuestPersonals(data: GuestPersonalUpdateManyMutationInput!, where: GuestPersonalWhereInput): BatchPayload!
  upsertGuestPersonal(where: GuestPersonalWhereUniqueInput!, create: GuestPersonalCreateInput!, update: GuestPersonalUpdateInput!): GuestPersonal!
  deleteGuestPersonal(where: GuestPersonalWhereUniqueInput!): GuestPersonal
  deleteManyGuestPersonals(where: GuestPersonalWhereInput): BatchPayload!
  createGuestResponse(data: GuestResponseCreateInput!): GuestResponse!
  updateGuestResponse(data: GuestResponseUpdateInput!, where: GuestResponseWhereUniqueInput!): GuestResponse
  updateManyGuestResponses(data: GuestResponseUpdateManyMutationInput!, where: GuestResponseWhereInput): BatchPayload!
  upsertGuestResponse(where: GuestResponseWhereUniqueInput!, create: GuestResponseCreateInput!, update: GuestResponseUpdateInput!): GuestResponse!
  deleteGuestResponse(where: GuestResponseWhereUniqueInput!): GuestResponse
  deleteManyGuestResponses(where: GuestResponseWhereInput): BatchPayload!
  createGuestRsvp(data: GuestRsvpCreateInput!): GuestRsvp!
  updateGuestRsvp(data: GuestRsvpUpdateInput!, where: GuestRsvpWhereUniqueInput!): GuestRsvp
  updateManyGuestRsvps(data: GuestRsvpUpdateManyMutationInput!, where: GuestRsvpWhereInput): BatchPayload!
  upsertGuestRsvp(where: GuestRsvpWhereUniqueInput!, create: GuestRsvpCreateInput!, update: GuestRsvpUpdateInput!): GuestRsvp!
  deleteGuestRsvp(where: GuestRsvpWhereUniqueInput!): GuestRsvp
  deleteManyGuestRsvps(where: GuestRsvpWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  guest(where: GuestWhereUniqueInput!): Guest
  guests(where: GuestWhereInput, orderBy: GuestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guest]!
  guestsConnection(where: GuestWhereInput, orderBy: GuestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuestConnection!
  guestContact(where: GuestContactWhereUniqueInput!): GuestContact
  guestContacts(where: GuestContactWhereInput, orderBy: GuestContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GuestContact]!
  guestContactsConnection(where: GuestContactWhereInput, orderBy: GuestContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuestContactConnection!
  guestPersonal(where: GuestPersonalWhereUniqueInput!): GuestPersonal
  guestPersonals(where: GuestPersonalWhereInput, orderBy: GuestPersonalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GuestPersonal]!
  guestPersonalsConnection(where: GuestPersonalWhereInput, orderBy: GuestPersonalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuestPersonalConnection!
  guestResponse(where: GuestResponseWhereUniqueInput!): GuestResponse
  guestResponses(where: GuestResponseWhereInput, orderBy: GuestResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GuestResponse]!
  guestResponsesConnection(where: GuestResponseWhereInput, orderBy: GuestResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuestResponseConnection!
  guestRsvp(where: GuestRsvpWhereUniqueInput!): GuestRsvp
  guestRsvps(where: GuestRsvpWhereInput, orderBy: GuestRsvpOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GuestRsvp]!
  guestRsvpsConnection(where: GuestRsvpWhereInput, orderBy: GuestRsvpOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuestRsvpConnection!
  node(id: ID!): Node
}

type Subscription {
  guest(where: GuestSubscriptionWhereInput): GuestSubscriptionPayload
  guestContact(where: GuestContactSubscriptionWhereInput): GuestContactSubscriptionPayload
  guestPersonal(where: GuestPersonalSubscriptionWhereInput): GuestPersonalSubscriptionPayload
  guestResponse(where: GuestResponseSubscriptionWhereInput): GuestResponseSubscriptionPayload
  guestRsvp(where: GuestRsvpSubscriptionWhereInput): GuestRsvpSubscriptionPayload
}
`
      }
    